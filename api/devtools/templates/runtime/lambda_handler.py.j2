# {{ tag_name | lower }}_lambda_handler.py
"""Auto-generated Lmabda Hander for for {{ tag_name }}"""

from {{ tag_name }}_handler_impl import {{ tag_name|capitalize }}Handler
from shared.api.response_model import APIResponseModel, ErrorModel
from shared.com.logging_utils import ProjectLogger

handler_instance = {{ tag_name|capitalize }}Handler()
logger = ProjectLogger("{{ tag_name|capitalize }}Lambda").get_logger()

def _extract_method_path(event):
    # REST API v1
    if "httpMethod" in event and "path" in event:
        return event["httpMethod"], event["path"]
    # HTTP API v2
    rc = event.get("requestContext", {}).get("http", {})
    method = rc.get("method")
    path = event.get("rawPath") or rc.get("path")
    return method, path

routes = {
{%- for endpoint in endpoints %}
    ("{{ endpoint.method }}", "{{ endpoint.path }}"): handler_instance.{{ endpoint.operationId | snake_case }}{% if not loop.last %},{% endif %}
{%- endfor %}
}


# Simple in-memory cache (lives as long as Lambda is warm)
cache = {}

# pylint: disable=too-many-branches
def lambda_handler(event, context):
    method, path = _extract_method_path(event)
    key = (method, path, event.get("queryStringParameters"))
    route = routes.get((method, path))
    if route is None:
        return {"statusCode": 404, "body": "Endpoint not found"}
    try:
        response = route(event, context, cache)
        # Validate response type
        if not isinstance(response, APIResponseModel):
            logger.error(f"Handler for {method} {path} did not return APIResponseModel. Got: {type(response)} | Value: {response}")
            error = ErrorModel(code="internal_error", message="Handler did not return a valid APIResponseModel.")
            return APIResponseModel(success=False, error=error, data=None, allowedActions={}, meta=None).model_dump()
        return response.model_dump() if hasattr(response, 'model_dump') else response
    except Exception as exc:  # pylint: disable=broad-except # Catch all to prevent Lambda crash
        logger.exception(f"Exception in handler for {method} {path}: {exc}")
        error = ErrorModel(code="internal_error", message="An unexpected error occurred.")
        return APIResponseModel(success=False, error=error, data=None, allowedActions={}, meta=None).model_dump()
